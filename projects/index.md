---
layout: default
---

Здесь представлен список тем для студенческих проектов, курсовых, дипломов и выпускных работ.

Если Вы заинтересованы в поиске темы в одной из моих областей интересов, но не нашли подходящей ниже и/или таковая уже занята --- просто напишите мне и мы постараемся сформулировать её вместе.

Сводная табличка тем: (см. описание ниже)
=========================================

|№  | Тема | Область | Свободна? |
|----------|:-------------|:------|:------:|
| 1 | Semi-local LCS + oneAPI (DPC++) | Semi-Local LCS and SA | Да |
| 2 | Semi-local LCS vs. Accel-alignment | Semi-Local LCS and SA | Да |
| 3 | Beta-версия плагина для языка Vyper | Software Engineering / Vyper / Smart-Contracts | Нет |
| 5 | Специализация низкоуровнего кода | Program Specialization | Да |
| 6 | Специализация трассирующих call-by-name интерпретаторов | Specialization and Traversal-Based Normalization | Да |


Описание тем
=========================================

## 1. Semi-local LCS + oneAPI (DPC++)

Задачи полу-локального поиска --- расширение стандартных задач поиска наибольшей общей подпоследовательности и выравнивания строк.
Актуальной является задача эффективной реализации существующих алгоритмов под разные архитектуры.
DPC++ --- своеобразное развитие языка C++, позволяющее использовать код для любой архитектуры (в т.ч. CUDA, FPGA, CPU, ...).
*Задача*: взять существующую реализацию ряда алгоритмов полулокального поиска (из нашей статьи на ICPP'21), адаптировать их для DPC++, протестировать на платформах, сравниться с битовым алгоритмом Hyyro.

Возможность публикацуии: на интеловскую конфу с эвалюэйшеном

Связанные работы: Наша статья на ICPP'21 (увы, пока нет в свободном доступе)

Курс: 3,4

Сложность: 3 (норм)

## 2. Semi-local LCS vs. Accel-alignment
Accel-align --- новый инструмент для выравнивания последовательностей (потенциально state-of-the-art).
Задача аккуратно разобраться в его сути, а также сравнить с недавно реализованными (нашими) алгоритмами полулокального поиска (провести evaluation с https://github.com/NikitaMishin/semilocal).

Возможность публикацуии: на студенческую конфу

Курс: 2, (м.б. 3)

Сложность: 3 (норм)

## 3. Beta-версия плагина для языка Vyper

Vyper --- набирающий популярность язык для написания смарт-контрактов, имеет pythonic синтаксис, не Тьюринг полный, реализован максимально безопасно. Отсутствует полноценная поддержка в Intellij Platform.
Есть частично готовый плагин для языка Vyper. Есть ряд issues, связанных с тем, что плагина нет в магазине плагинов в Intellij Platform.
Задача стоит в расширении функциональности плагина, а также завершения его в минимальный work product (чтобы любой пользователь мог его установить через магазин).

Студент в процессе разработки: 

1. научиться писать плагины под Intellij Platform
2. прокачает написание кода на Kotlin
3. Выгодно тем, что если студенту понравится, то он будет в принципе готов быть джуном (мю) в команде разработки плагинов
4. Много технических деталей
5. Чтение чужого кода, написание кода (возможно придется написать заново)
6. Добавление новых фич:
  - Поддержка ошибок компиляции в коде
  - Анализ кода
  - Инфраструктура тестирования (Например, можно посмотреть на то, как сделано тестирование с помощью DSL для Scala)
  - Autocomplete
  - ....

Связанные работы: Курсовые Мишина и Тюрина

Возможность публикации: На студенческую или/ техническую конфу

Курс: 2, (м.б. 3)

Сложность: 3 (норм); много разных вариантов развития плагина

## 4. Специализация низкоуровнего кода

Специализация кода, генерируемого компилятором с курса компиляторов на его целевом языке. В идеале --- добиться его самоприменения.

Связанные работы:
- PE of C
- partial evaluation of machine code

Возможность публикации: Да (например, тематический воркшоп уровня B)

Курс: 3, 4

Сложность: >= 4

## 5. Специализация трассирующих call-by-name интерпретаторов

Проверить утверждение (formally + implement) про то, что трассирующая нормализация действительно позволяет с помощью umix генерировать хорошие компиляторы для языков по их интерпретаторам, по крайней мере в случае call-by-name интерпретатора.

Возможность публикации: На студенческой конфе и/или м.б. на тематическом воркшопе

Курс: 2--3 курс

Сложность: ~2--3, но надо будет разобраться со специализацией и Scheme


# Недооформленные темы / идеи

## Semi-local algorithms with AVX512 [Semi-Local LCS and SA]

Intra-processor parallelism in AVX512Subword-parallel iterative combing on AVX512BW (combing logic via VPCMPUB, VPMAXUB/VPMINUB).
Bit-parallel iterative combing on AVX512VL+AVX512F (combing logic via VPTERNLOGD).

Должно быть публикабельно в нормальном месте

3--4 курс

норм (2.5 -- 3)

## Сайт для поиска конференций (+ phd и т.п.)   [Инф.поиск + соц.сети + сайты]

Создать "сайт-инфраструктуру" для поиска всякой академической информации а-ля конференции, phd, вакансии и т.п.	?!

stringology, conferenceraks, wikicfp

2--3 курс

~2, много разных вариантов развития

## [Specialization]

Разработать general framework для генерации всего-всего (интерпретаторов, компиляторов, чекеров, верификаторов,…) по описанию семантики языков --- a la K-framework, но круче ;)

Да

Any

1--2

Сложно (4--5)


## [Specialization]

On-the-fly specialization аки плагин для IDE (профилятора)

TODO: research a little
Да

- Trace-based Just-in-Time Type Specialization for Dynamic Languages
- Just-in-Time Value Specialization
- Representation-Based Just-In-Time Specialization and the Psyco Prototype for Python
- Guided just-in-time specialization
- Optimizing Matlab through Just-In-Time Specialization
TODO
TODO

## Абстрактная интерпретация для C

Static analysis	TODO: research

TODO

TODO

3, 4, мага

TODO

## Верификация полу-локальных алгосов и теории на Coq [Verification]

TODO: specify what and how exactly

TODO

TODO

3, 4, мага

TODO


## Haskell^{-1} + interleaving ~===~ minicanren?

(automatic function inversion in haskell. Teegen, Prott, Bunkenburg)

## Dynamic compiler for ocanren

## TODO

implement an interpreter for some invertible language in minikanren and check that we can run it in different directions